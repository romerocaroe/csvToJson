"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uploadLogo = exports.updateLogo = exports.updateLang = exports.updateCustomization = exports.updateColors = exports.findCustomization = exports.createCustomization = void 0;

var _CustomizationModel = _interopRequireDefault(require("../models/CustomizationModel"));

var _apolloServerExpress = require("apollo-server-express");

var _fs = _interopRequireDefault(require("fs"));

var _createDirIfNotExist = _interopRequireDefault(require("./helpers/createDirIfNotExist"));

var _loggerBackend = require("@dracul/logger-backend");

var _stream = require("stream");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const path = require('path');

const findCustomization = async function () {
  return new Promise((resolve, reject) => {
    _CustomizationModel.default.findOne().exec((err, res) => {
      err ? reject(err) : resolve(res);
    });
  });
};

exports.findCustomization = findCustomization;

const createCustomization = async function ({
  colors,
  logo,
  language
}) {
  const doc = new _CustomizationModel.default({
    colors,
    logo,
    language
  });
  doc.id = doc._id;
  return new Promise((resolve, rejects) => {
    doc.save(error => {
      if (error) {
        if (error.name == "ValidationError") {
          rejects(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        }

        rejects(error);
      }

      resolve(doc);
    });
  });
};

exports.createCustomization = createCustomization;

const updateCustomization = async function (id, {
  colors,
  logo,
  language
}) {
  return new Promise((resolve, rejects) => {
    _CustomizationModel.default.findOneAndUpdate({
      _id: id
    }, {
      colors,
      logo,
      language
    }, {
      new: true,
      runValidators: true,
      context: 'query'
    }, (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          rejects(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        }

        rejects(error);
      }

      resolve(doc);
    });
  });
};

exports.updateCustomization = updateCustomization;

const updateColors = async function ({
  primary,
  onPrimary,
  secondary,
  onSecondary
}) {
  return new Promise((resolve, rejects) => {
    let colors = {
      primary,
      onPrimary,
      secondary,
      onSecondary
    };

    _CustomizationModel.default.findOneAndUpdate({}, {
      colors
    }, {
      new: true,
      runValidators: true,
      context: 'query',
      useFindAndModify: false
    }, (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          rejects(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        }

        rejects(error);
      }

      resolve(doc.colors);
    });
  });
};

exports.updateColors = updateColors;

const updateLogo = async function ({
  mode,
  title
}) {
  return new Promise((resolve, rejects) => {
    _CustomizationModel.default.findOneAndUpdate({}, {
      $set: {
        'logo.mode': mode,
        'logo.title': title
      }
    }, {
      new: true,
      runValidators: true,
      context: 'query',
      useFindAndModify: false
    }, (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          rejects(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        }

        rejects(error);
      }

      resolve(doc.logo);
    });
  });
};

exports.updateLogo = updateLogo;

const updateLang = async function ({
  language
}) {
  return new Promise((resolve, rejects) => {
    _CustomizationModel.default.findOneAndUpdate({}, {
      language
    }, {
      new: true,
      runValidators: true,
      context: 'query'
    }, (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          rejects(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        }

        rejects(error);
      }

      resolve(doc);
    });
  });
};

exports.updateLang = updateLang;

class StreamSizeValidator extends _stream.Transform {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "maxFileSize", process.env.LOGO_MAX_SIZE ? process.env.LOGO_MAX_SIZE : 2000000);

    _defineProperty(this, "length", 0);
  }

  _transform(chunk, encoding, callback) {
    this.length += chunk.length;

    if (this.length > this.maxFileSize) {
      this.destroy(new Error(`MAX_FILE_SIZE_EXCEEDED`));
      return;
    }

    this.push(chunk);
    callback();
  }

}

const storeFS = (sourceStream, dst) => {
  return new Promise((resolve, reject) => {
    const sizeValidator = new StreamSizeValidator();

    const fileWriteStream = _fs.default.createWriteStream(dst);

    sourceStream.on('error', error => {
      if (sourceStream.truncated) {
        _fs.default.unlinkSync(dst);
      }

      fileWriteStream.destroy(error);
      sizeValidator.destroy(error);
      sourceStream.destroy();

      _loggerBackend.DefaultLogger.error("CustomizationService.storeFS: sourceStream error: ", error.message);

      reject(error);
    });
    sizeValidator.on("error", error => {
      _loggerBackend.DefaultLogger.error("CustomizationService.storeFS: sizeValidator error: ", error);

      sourceStream.destroy(error);
      fileWriteStream.destroy(error);
      reject(error);
    });
    fileWriteStream.on('error', error => {
      _loggerBackend.DefaultLogger.error("CustomizationService.storeFS: fileWriteStream error: ", error);

      fileWriteStream.destroy();
      sourceStream.destroy(error);
      sizeValidator.destroy(error);
      reject(error);
    }).on('finish', () => {
      _loggerBackend.DefaultLogger.info('CustomizationService.storeFS finish successful');

      resolve(true);
    });
    sourceStream.pipe(sizeValidator).pipe(fileWriteStream);
  });
};

function randomstring(length) {
  let result = '';
  let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let charactersLength = characters.length;

  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
}

const uploadLogo = function (file) {
  return new Promise(async (resolve, reject) => {
    const mimetypesAllowed = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];

    try {
      const {
        filename,
        mimetype,
        encoding,
        createReadStream
      } = await file;

      if (!mimetypesAllowed.includes(mimetype)) {
        reject(new Error("MIMETYPE_NOT_ALLOWED"));
        return;
      }

      const dst = path.join("media", "logo", filename); //Store

      (0, _createDirIfNotExist.default)(dst);
      storeFS(createReadStream(), dst).then(() => {
        const rand = randomstring(3);
        const url = process.env.APP_API_URL + "/media/logo/" + filename + "?" + rand;
        let logo = {
          filename,
          url
        };

        _CustomizationModel.default.findOneAndUpdate({}, {
          $set: {
            'logo.filename': filename,
            'logo.url': url
          }
        }, {
          useFindAndModify: false
        }, error => {
          if (error) {
            _loggerBackend.DefaultLogger.error("CustomizationService.logoUpload: update fail", error);

            reject(new Error("Save Fail"));
          } else {
            _loggerBackend.DefaultLogger.debug('CustomizationService.logoUpload successful');

            resolve({
              filename,
              mimetype,
              encoding,
              url
            });
          }
        }); ////////////////

      }).catch(err => {
        _loggerBackend.DefaultLogger.error("CustomizationService.logoUpload: store fail", err);

        reject(new Error(err.message));
      });
    } catch (e) {
      _loggerBackend.DefaultLogger.error("CustomizationService.logoUpload: store fail", e);

      console.log("ERRRR", e.message);
      reject(new Error(e.message));
    }
  });
};

exports.uploadLogo = uploadLogo;