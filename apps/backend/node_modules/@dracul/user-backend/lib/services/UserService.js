"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateUser = exports.setUsersGroups = exports.restoreDeletedUser = exports.paginateUsers = exports.hashPassword = exports.findUsersGroup = exports.findUsersByRole = exports.findUsers = exports.findUserByUsernameOrEmailDeleted = exports.findUserByUsernameOrEmail = exports.findUserByUsername = exports.findUserByRefreshToken = exports.findUserByEmail = exports.findUser = exports.deleteUser = exports.createUser = exports.changePasswordAdmin = exports.UserEventEmitter = void 0;

var _loggerBackend = require("@dracul/logger-backend");

var _UserModel = _interopRequireDefault(require("../models/UserModel"));

require("../models/GroupModel");

var _UserAuditService = require("./UserAuditService");

var _bcryptjs = _interopRequireDefault(require("bcryptjs"));

var _apolloServerExpress = require("apollo-server-express");

var _GroupService = require("./GroupService");

var _RoleService = require("./RoleService");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const EventEmitter = require('events');

let UserEventEmitter = new EventEmitter();
exports.UserEventEmitter = UserEventEmitter;

const hashPassword = function (password) {
  if (!password) {
    throw new Error("password must be provided");
  }

  let salt = _bcryptjs.default.genSaltSync(10);

  let hashPassword = _bcryptjs.default.hashSync(password, salt);

  return hashPassword;
};

exports.hashPassword = hashPassword;

const restoreDeletedUser = function (id, {
  username,
  password,
  name,
  email,
  phone,
  role,
  groups,
  active,
  refreshToken
}, actionBy = null) {
  return new Promise(async (resolve, reject) => {
    _loggerBackend.DefaultLogger.info('UserService.restoreDeletedUser restoring id: ' + id + ' username: ' + username);

    let updatedAt = Date.now(); //Prepare group push and pull

    let toRemoveGroups = [];
    let toAddGroups = [];
    let oldGroups = await (0, _GroupService.fetchMyGroups)(id);

    if (oldGroups && oldGroups.length) {
      toRemoveGroups = oldGroups.filter(group => !groups.some(ngroup => ngroup.id === group.id));
    }

    if (groups && groups.length) {
      toAddGroups = groups.filter(group => !oldGroups.some(ngroup => ngroup.id === group.id));
    }

    _UserModel.default.findOneAndUpdate({
      _id: id
    }, {
      name: name.trim(),
      username: username.trim(),
      email: email.trim(),
      password: hashPassword(password),
      phone,
      role,
      groups,
      active,
      updatedAt,
      refreshToken,
      deleted: false,
      deletedAt: null
    }, {
      new: true,
      runValidators: true,
      context: 'query'
    }, async (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          _loggerBackend.DefaultLogger.warn("updateUser ValidationError ", error);

          reject(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        } else {
          _loggerBackend.DefaultLogger.error("UserService.updateUser ", error);
        }

        reject(error);
      } else {
        //Add user to groups
        //console.log("toAddGroups", toAddGroups)
        if (toAddGroups && toAddGroups.length) {
          for (let groupId of toAddGroups) {
            await (0, _GroupService.addUserToGroup)(groupId, doc._id);
          }
        } //Remove user to groups
        //console.log("toRemoveGroups", toRemoveGroups)


        if (toRemoveGroups && toRemoveGroups.length) {
          for (let group of toRemoveGroups) {
            await (0, _GroupService.removeUserToGroup)(group.id, doc._id);
          }
        }

        _loggerBackend.DefaultLogger.info('UserService.restoreDeletedUser successful for ' + doc.username);

        (0, _UserAuditService.createUserAudit)(actionBy ? actionBy.id : null, doc._id, 'userRestored');
        doc.populate('role').populate('groups').execPopulate(() => {
          UserEventEmitter.emit('updated', doc);
          resolve(doc);
        });
      }
    });
  });
};

exports.restoreDeletedUser = restoreDeletedUser;

const createUser = async function ({
  username,
  password,
  name,
  email,
  phone,
  role,
  groups,
  active,
  fromLDAP = false
}, actionBy = null) {
  const existingUser = await findUserByUsernameOrEmailDeleted(username, email);

  if (existingUser) {
    return restoreDeletedUser(existingUser._id, {
      username,
      password,
      name,
      email,
      phone,
      role,
      groups,
      active,
      fromLDAP
    }, actionBy = null);
  }

  const newUser = new _UserModel.default({
    name: name.trim(),
    username: username.trim(),
    email: email.trim(),
    password: hashPassword(password),
    phone,
    active,
    role,
    groups,
    createdAt: Date.now(),
    refreshToken: [],
    fromLDAP
  });
  return new Promise((resolve, reject) => {
    newUser.save(async (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          _loggerBackend.DefaultLogger.warn("createUser ValidationError ", error);

          reject(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        } else {
          _loggerBackend.DefaultLogger.error("UserService.createUser ", error);
        }

        reject(error);
      } else {
        if (groups && groups.length) {
          for (let group of groups) {
            await (0, _GroupService.addUserToGroup)(group, doc._id);
          }
        }

        _loggerBackend.DefaultLogger.info('UserService.createUser successful for ' + doc.username);

        (0, _UserAuditService.createUserAudit)(actionBy ? actionBy.id : null, doc._id, 'userCreated');
        doc.populate('role').populate('groups').execPopulate(() => {
          UserEventEmitter.emit('created', doc);
          resolve(doc);
        });
      }
    });
  });
};

exports.createUser = createUser;

const updateUser = function (id, {
  username,
  name,
  email,
  phone,
  role,
  groups,
  active,
  refreshToken
}, actionBy = null) {
  return new Promise(async (resolve, reject) => {
    let updatedAt = Date.now(); //Prepare group push and pull

    let toRemoveGroups = [];
    let toAddGroups = [];
    let oldGroups = await (0, _GroupService.fetchMyGroups)(id);

    if (oldGroups && oldGroups.length) {
      toRemoveGroups = oldGroups.filter(group => !groups.some(ngroup => ngroup.id === group.id));
    }

    if (groups && groups.length) {
      toAddGroups = groups.filter(group => !oldGroups.some(ngroup => ngroup.id === group.id));
    }

    _UserModel.default.findOneAndUpdate({
      _id: id
    }, {
      name: name.trim(),
      username: username.trim(),
      email: email.trim(),
      phone,
      role,
      groups,
      active,
      updatedAt,
      refreshToken
    }, {
      new: true,
      runValidators: true,
      context: 'query'
    }, async (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          _loggerBackend.DefaultLogger.warn("updateUser ValidationError ", error);

          reject(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        } else {
          _loggerBackend.DefaultLogger.error("UserService.updateUser ", error);
        }

        reject(error);
      } else {
        //Add user to groups
        //console.log("toAddGroups", toAddGroups)
        if (toAddGroups && toAddGroups.length) {
          for (let groupId of toAddGroups) {
            await (0, _GroupService.addUserToGroup)(groupId, doc._id);
          }
        } //Remove user to groups
        //console.log("toRemoveGroups", toRemoveGroups)


        if (toRemoveGroups && toRemoveGroups.length) {
          for (let group of toRemoveGroups) {
            await (0, _GroupService.removeUserToGroup)(group.id, doc._id);
          }
        }

        _loggerBackend.DefaultLogger.info('UserService.updateUser successful for ' + doc.username);

        (0, _UserAuditService.createUserAudit)(actionBy ? actionBy.id : null, doc._id, 'userModified');
        doc.populate('role').populate('groups').execPopulate(() => {
          UserEventEmitter.emit('updated', doc);
          resolve(doc);
        });
      }
    });
  });
};

exports.updateUser = updateUser;

const deleteUser = function (id, actionBy = null) {
  return new Promise((resolve, reject) => {
    findUser(id).then(doc => {
      doc.softdelete(function (err) {
        (0, _UserAuditService.createUserAudit)(actionBy ? actionBy.id : null, doc._id, 'userDeleted');

        if (err) {
          _loggerBackend.DefaultLogger.error("UserService.deleteUser ", err);

          reject(err);
        } else {
          _loggerBackend.DefaultLogger.info('UserService.deleteUser successful for ' + doc.username);

          UserEventEmitter.emit('deleted', doc);
          resolve({
            success: true,
            id: id
          });
        }
      });
    });
  });
};

exports.deleteUser = deleteUser;

const findUsers = function (roles = [], userId = null) {
  return new Promise((resolve, reject) => {
    let qs = {};

    if (roles && roles.length) {
      qs = {
        $or: [{
          role: {
            $in: roles
          }
        }, {
          _id: userId
        }]
      };
    }

    _UserModel.default.find(qs).isDeleted(false).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUsers ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUsers successful');

        resolve(res);
      }
    });
  });
};

exports.findUsers = findUsers;

const findUsersByRole = function (roleName) {
  return new Promise(async (resolve, reject) => {
    let role = await (0, _RoleService.findRoleByName)(roleName);
    if (!role) return resolve([]);

    _UserModel.default.find({
      role: role.id
    }).isDeleted(false).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUsersByRole ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUsersByRole successful');

        resolve(res);
      }
    });
  });
};

exports.findUsersByRole = findUsersByRole;

const paginateUsers = function (limit, pageNumber = 1, search = null, orderBy = null, orderDesc = false, roles = [], activeUsers = false) {
  function getQuery(search) {
    let qs = {};

    if (search) {
      qs = {
        $or: [{
          name: {
            $regex: search,
            $options: 'i'
          }
        }, {
          username: {
            $regex: search,
            $options: 'i'
          }
        }, {
          email: {
            $regex: search,
            $options: 'i'
          }
        }, {
          phone: {
            $regex: search,
            $options: 'i'
          }
        }]
      };
    }

    if (roles && roles.length) {
      qs.role = {
        $in: roles
      };
    }

    if (activeUsers) {
      qs.active = true;
    }

    return qs;
  }

  function getSort(orderBy, orderDesc) {
    if (orderBy) {
      return (orderDesc ? '-' : '') + orderBy;
    } else {
      return null;
    }
  }

  let query = {
    deleted: false,
    ...getQuery(search)
  };
  let populate = ['role', 'groups'];
  let sort = getSort(orderBy, orderDesc);
  let params = {
    page: pageNumber,
    limit: limit,
    populate: populate,
    sort
  };
  return new Promise((resolve, reject) => {
    _UserModel.default.paginate(query, params).then(result => {
      _loggerBackend.DefaultLogger.debug('UserService.paginateUsers successful');

      resolve({
        users: result.docs,
        totalItems: result.totalDocs,
        page: result.page
      });
    }).catch(err => {
      _loggerBackend.DefaultLogger.error("UserService.paginateUsers ", err);

      reject(err);
    });
  });
};

exports.paginateUsers = paginateUsers;

const findUser = function (id) {
  return new Promise((resolve, reject) => {
    _UserModel.default.findOne({
      _id: id
    }).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUser ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUser successful');

        resolve(res);
      }
    });
  });
};

exports.findUser = findUser;

const findUserByUsername = function (username) {
  return new Promise((resolve, reject) => {
    _UserModel.default.findOne({
      username: username
    }).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUserByUsername ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUserByUsername successful');

        resolve(res);
      }
    });
  });
};

exports.findUserByUsername = findUserByUsername;

const findUserByEmail = function (email) {
  return new Promise((resolve, reject) => {
    _UserModel.default.findOne({
      email: email
    }).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUserByEmail ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUserByEmail successful');

        resolve(res);
      }
    });
  });
};

exports.findUserByEmail = findUserByEmail;

const findUserByUsernameOrEmail = function (username, email) {
  return new Promise((resolve, reject) => {
    _UserModel.default.findOne({
      $or: [{
        username: username
      }, {
        email: email
      }]
    }).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUserByEmail ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUserByEmail successful');

        resolve(res);
      }
    });
  });
};

exports.findUserByUsernameOrEmail = findUserByUsernameOrEmail;

const findUserByUsernameOrEmailDeleted = function (username, email) {
  return new Promise((resolve, reject) => {
    _UserModel.default.findOne({
      $or: [{
        username: username
      }, {
        email: email
      }],
      deleted: true
    }).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUserByEmail ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUserByEmail successful');

        resolve(res);
      }
    });
  });
};

exports.findUserByUsernameOrEmailDeleted = findUserByUsernameOrEmailDeleted;

const changePasswordAdmin = function (id, {
  password,
  passwordVerify
}, actionBy = null) {
  if (password == passwordVerify) {
    return new Promise((resolve, reject) => {
      _UserModel.default.findOneAndUpdate({
        _id: id
      }, {
        password: hashPassword(password)
      }, {
        new: true
      }, (err, doc) => {
        if (err) {
          _loggerBackend.DefaultLogger.error("UserService.changePasswordAdmin ", err);

          reject({
            status: false,
            message: "Change password fail"
          });
        } else {
          _loggerBackend.DefaultLogger.debug('UserService.changePasswordAdmin successful');

          (0, _UserAuditService.createUserAudit)(actionBy.id, id, actionBy.id === id ? 'userPasswordChange' : 'changePasswordAdmin');
          resolve({
            success: true,
            message: "PasswordChange",
            operation: "changePasswordAdmin"
          });
        }
      });
    });
  } else {
    return new Promise((resolve, _reject) => {
      resolve({
        status: false,
        message: "Password doesn't match"
      });
    });
  }
};

exports.changePasswordAdmin = changePasswordAdmin;

const findUsersGroup = function (group) {
  return new Promise((resolve, reject) => {
    _UserModel.default.find({
      groups: group.id
    }).then(users => {
      _loggerBackend.DefaultLogger.debug('UserService.findUsersGroup successful');

      resolve(users);
    }).catch(err => {
      _loggerBackend.DefaultLogger.error("UserService.findUsersGroup ", err);

      reject(err);
    });
  });
};

exports.findUsersGroup = findUsersGroup;

const setUsersGroups = function (group, users) {
  function getDeletePromises(oldUsers) {
    return oldUsers.map(oldUser => {
      let index = users.indexOf(oldUser.id);

      if (index !== -1) {
        users.splice(index, 1);
      } else {
        // console.log("Deleting user " + oldUser.username + ' for ' + group.id)
        return _UserModel.default.findOneAndUpdate({
          _id: oldUser.id
        }, {
          $pullAll: {
            groups: [group.id]
          }
        }, {
          new: true,
          runValidators: true,
          context: 'query'
        });
      }
    });
  }

  function getPushPromises() {
    return users.map(user => {
      return _UserModel.default.findOneAndUpdate({
        _id: user
      }, {
        $push: {
          groups: group.id
        }
      }, {
        new: true,
        runValidators: true,
        context: 'query'
      });
    });
  }

  return new Promise(async (resolve, reject) => {
    findUsersGroup(group).then(oldUsers => {
      Promise.all(getDeletePromises(oldUsers)).then(() => {
        //2. Push group in new users
        let pushPromises = getPushPromises();
        Promise.all(pushPromises).then(() => {
          _loggerBackend.DefaultLogger.debug('UserService.setUsersGroups successful');

          resolve(true);
        }).catch(err => reject(err));
      }).catch(err => {
        _loggerBackend.DefaultLogger.error("UserService.setUsersGroups ", err);

        reject(err);
      });
    }).catch(e => {
      _loggerBackend.DefaultLogger.error("UserService.setUsersGroups.findUsersGroup ", e);

      reject(e);
    });
  });
};

exports.setUsersGroups = setUsersGroups;

const findUserByRefreshToken = function (id) {
  return new Promise(async (resolve, reject) => {
    let now = new Date();

    _UserModel.default.findOne({
      active: true,
      'refreshToken.id': id,
      'refreshToken.expiryDate': {
        $gte: now
      }
    }).populate('role').populate('groups').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("UserService.findUserByRefreshToken ", err);

        reject(err);
      } else {
        _loggerBackend.DefaultLogger.debug('UserService.findUserByRefreshToken successful');

        resolve(res);
      }
    });
  });
};

exports.findUserByRefreshToken = findUserByRefreshToken;