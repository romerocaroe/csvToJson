"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changePassword = exports.avatarUpload = void 0;

var _path = _interopRequireDefault(require("path"));

var _createDirIfNotExist = _interopRequireDefault(require("./utils/createDirIfNotExist"));

var _UserModel = _interopRequireDefault(require("../models/UserModel"));

var _loggerBackend = require("@dracul/logger-backend");

var _UserAuditService = require("./UserAuditService");

var _fs = _interopRequireDefault(require("fs"));

var _bcryptjs = _interopRequireDefault(require("bcryptjs"));

var _apolloServerExpress = require("apollo-server-express");

var _UserService = require("./UserService");

var _stream = require("stream");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

require('dotenv').config();

class StreamSizeValidator extends _stream.Transform {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "maxFileSize", process.env.AVATAR_MAX_SIZE ? process.env.AVATAR_MAX_SIZE : 2000000);

    _defineProperty(this, "length", 0);
  }

  _transform(chunk, encoding, callback) {
    this.length += chunk.length;

    if (this.length > this.maxFileSize) {
      this.destroy(new Error(`MAX_FILE_SIZE_EXCEEDED`));
      return;
    }

    this.push(chunk);
    callback();
  }

}

const storeFS = (sourceStream, dst) => {
  return new Promise((resolve, reject) => {
    const sizeValidator = new StreamSizeValidator();

    const fileWriteStream = _fs.default.createWriteStream(dst);

    sourceStream.on('error', error => {
      if (sourceStream.truncated) {
        _fs.default.unlinkSync(dst);
      }

      fileWriteStream.destroy(error);
      sizeValidator.destroy(error);
      sourceStream.destroy();

      _loggerBackend.DefaultLogger.error("UserService.storeFS: sourceStream error: ", error.message);

      reject(error);
    });
    sizeValidator.on("error", error => {
      _loggerBackend.DefaultLogger.error("UserService.storeFS: sizeValidator error: ", error);

      sourceStream.destroy(error);
      fileWriteStream.destroy(error);
      reject(error);
    });
    fileWriteStream.on('error', error => {
      _loggerBackend.DefaultLogger.error("UserService.storeFS: fileWriteStream error: ", error);

      fileWriteStream.destroy();
      sourceStream.destroy(error);
      sizeValidator.destroy(error);
      reject(error);
    }).on('finish', () => {
      _loggerBackend.DefaultLogger.info('UserService.storeFS finish successful');

      resolve(true);
    });
    sourceStream.pipe(sizeValidator).pipe(fileWriteStream);
  });
};

const avatarUpload = function (user, file) {
  return new Promise(async (resolve, reject) => {
    const mimetypesAllowed = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];

    try {
      const {
        filename,
        mimetype,
        encoding,
        createReadStream
      } = await file;

      if (!mimetypesAllowed.includes(mimetype)) {
        reject(new Error("MIMETYPE_NOT_ALLOWED"));
        return;
      }

      const parseFileName = _path.default.parse(filename);

      const finalFileName = user.username + parseFileName.ext;

      const dst = _path.default.join("media", "avatar", finalFileName); //Store


      (0, _createDirIfNotExist.default)(dst);
      storeFS(createReadStream(), dst).then(() => {
        const rand = randomstring(3);
        const url = process.env.APP_API_URL + "/media/avatar/" + finalFileName + "?" + rand;

        _UserModel.default.findOneAndUpdate({
          _id: user.id
        }, {
          avatar: finalFileName,
          avatarurl: url
        }, {
          useFindAndModify: false
        }, error => {
          if (error) {
            _loggerBackend.DefaultLogger.error("UserService.avatarUpload: update fail", error);

            reject(error);
          } else {
            _loggerBackend.DefaultLogger.debug('UserService.avatarUpload successful');

            (0, _UserAuditService.createUserAudit)(user.id, user.id, 'avatarChange');
            resolve({
              filename,
              mimetype,
              encoding,
              url
            });
          }
        });
      }).catch(err => {
        _loggerBackend.DefaultLogger.error("UserService.avatarUpload: store fail", err);

        reject(new Error(err.message));
      });
    } catch (e) {
      _loggerBackend.DefaultLogger.error("UserService.avatarUpload: store fail", e);

      reject(new Error(e.message));
    }
  });
};

exports.avatarUpload = avatarUpload;

function randomstring(length) {
  let result = '';
  let characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let charactersLength = characters.length;

  for (var i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }

  return result;
}

const changePassword = function (id, {
  currentPassword,
  newPassword
}, actionBy = null) {
  return new Promise(async (resolve, rejects) => {
    if (!currentPassword || !newPassword) {
      return rejects(new Error('Current password and new password must not be null or empty'));
    }

    if (currentPassword === newPassword) {
      rejects(new _apolloServerExpress.UserInputError('auth.messagePasswordIsEqual', {
        inputErrors: {
          newPassword: {
            properties: {
              message: 'auth.messagePasswordIsEqual'
            }
          }
        }
      }));
    }

    let user = await _UserModel.default.findOne({
      _id: id
    });

    if (_bcryptjs.default.compareSync(currentPassword, user.password)) {
      _UserModel.default.findOneAndUpdate({
        _id: id
      }, {
        password: (0, _UserService.hashPassword)(newPassword)
      }, {
        new: true
      }, (err, doc) => {
        if (err) {
          _loggerBackend.DefaultLogger.error("UserService.changePassword ", err);

          rejects(error);
        } else {
          _loggerBackend.DefaultLogger.debug('UserService.changePassword successful');

          (0, _UserAuditService.createUserAudit)(actionBy.id, id, actionBy.id === id ? 'userPasswordChange' : 'adminPasswordChange');
          resolve({
            status: true,
            message: "Password Changed"
          });
        }
      });
    } else {
      _loggerBackend.DefaultLogger.warn("UserService.changePassword: password doesnt match");

      rejects(new _apolloServerExpress.UserInputError('auth.wrongPassword', {
        inputErrors: {
          currentPassword: {
            properties: {
              message: 'auth.wrongPassword'
            }
          }
        }
      }));
    }
  });
};

exports.changePassword = changePassword;