"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rootRecover = exports.initSupervisorUser = exports.initSupervisorRole = exports.initRootUser = exports.initRoles = exports.initPermissions = exports.initOperatorUser = exports.initOperatorRole = exports.initLdapSettings = exports.initAdminRole = void 0;

var _loggerBackend = require("@dracul/logger-backend");

var _RoleService = require("./RoleService");

var _UserService = require("./UserService");

var _PermissionService = require("./PermissionService");

var _admin = _interopRequireDefault(require("../roles/admin"));

var _supervisor = _interopRequireDefault(require("../roles/supervisor"));

var _operator = _interopRequireDefault(require("../roles/operator"));

var _rootUser = require("../data/root-user");

var _supervisorUser = require("../data/supervisor-user");

var _operatorUser = require("../data/operator-user");

var _permissions = require("../permissions");

var _ldapSettings = require("../data/ldap-settings");

var _settingsBackend = require("@dracul/settings-backend");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const initPermissions = async permissions => {
  if (!permissions) {
    permissions = [_permissions.SECURITY_USER_CREATE, _permissions.SECURITY_USER_EDIT, _permissions.SECURITY_USER_DELETE, _permissions.SECURITY_USER_SHOW, _permissions.SECURITY_GROUP_CREATE, _permissions.SECURITY_GROUP_EDIT, _permissions.SECURITY_GROUP_DELETE, _permissions.SECURITY_GROUP_SHOW, _permissions.SECURITY_ROLE_CREATE, _permissions.SECURITY_ROLE_SHOW, _permissions.SECURITY_ROLE_SHOW_CHILD, _permissions.SECURITY_ROLE_EDIT, _permissions.SECURITY_ROLE_DELETE, _permissions.SECURITY_DASHBOARD_SHOW, _permissions.SECURITY_ADMIN_MENU];
  } //Fetch permissions already created


  let permissionsFound = await (0, _PermissionService.fetchPermissionsInName)(permissions); //Filter permissions created (avoid duplicate)

  let permissionToCreate;

  if (permissionsFound) {
    permissionToCreate = permissions.filter(p => !permissionsFound.some(f => f.name == p));
  } else {
    permissionToCreate = permissions;
  } //permissions Found


  if (permissionsFound.length > 0) {
    _loggerBackend.DefaultLogger.debug("Permissions found: " + permissionsFound.map(p => p.name).toString());
  } // Exec All Create Promises


  let permissionsCreated = await Promise.all(permissionToCreate.map(name => (0, _PermissionService.createPermission)(name)));

  if (permissionsCreated.length > 0) {
    _loggerBackend.DefaultLogger.info("Permissions created: " + permissionsCreated.map(p => p.name).toString());
  }
};

exports.initPermissions = initPermissions;

function loggingEvent(event, entity, name, id) {
  let message = entity + " " + event + ": < name=" + name + " id=" + id + " >";

  switch (event) {
    case "created":
      _loggerBackend.DefaultLogger.info(message);

      break;

    case "updated":
    case "found":
      _loggerBackend.DefaultLogger.debug(message);

      break;

    default:
      _loggerBackend.DefaultLogger.debug(message);

  }
}

const initAdminRole = async () => {
  let adminRoleT = await (0, _admin.default)();
  let adminRole = await (0, _RoleService.findRoleByName)(adminRoleT.name);

  if (adminRole) {
    let adminRoleUpdated = await (0, _RoleService.updateRole)(adminRole.id, {
      name: adminRoleT.name,
      permissions: adminRoleT.permissions,
      readonly: true
    });
    loggingEvent("updated", "role", adminRoleUpdated.name, adminRoleUpdated.id);
  } else {
    adminRole = await (0, _RoleService.createRole)(adminRoleT);
    loggingEvent("created", "role", adminRole.name, adminRole.id);
  }
};

exports.initAdminRole = initAdminRole;

const initSupervisorRole = async () => {
  let supervisorRoleT = await (0, _supervisor.default)();
  let supervisorRole = await (0, _RoleService.findRoleByName)(supervisorRoleT.name);

  if (supervisorRole) {
    let supervisorRoleUpdated = await (0, _RoleService.updateRole)(supervisorRole.id, {
      name: supervisorRoleT.name,
      childRoles: supervisorRoleT.childRoles,
      permissions: supervisorRoleT.permissions,
      readonly: true
    });
    loggingEvent("updated", "role", supervisorRoleUpdated.name, supervisorRoleUpdated.id);
  } else {
    supervisorRole = await (0, _RoleService.createRole)(supervisorRoleT);
    loggingEvent("created", "role", supervisorRole.name, supervisorRole.id);
  }
};

exports.initSupervisorRole = initSupervisorRole;

const initOperatorRole = async () => {
  let operatorRoleT = await (0, _operator.default)();
  let operatorRole = await (0, _RoleService.findRoleByName)(operatorRoleT.name);

  if (operatorRole) {
    let operatorRoleUpdated = await (0, _RoleService.updateRole)(operatorRole.id, {
      name: operatorRoleT.name,
      permissions: operatorRoleT.permissions,
      readonly: true
    });
    loggingEvent("updated", "role", operatorRoleUpdated.name, operatorRoleUpdated.id);
  } else {
    operatorRole = await (0, _RoleService.createRole)(operatorRoleT);
    loggingEvent("created", "role", operatorRole.name, operatorRole.id);
  }
};

exports.initOperatorRole = initOperatorRole;

const initRoles = async roles => {
  if (!roles) {
    roles = [(0, _operator.default)()];
  }

  let rolesName = roles.map(r => r.name); //Fetch roles already created

  let rolesFound = await (0, _RoleService.fetchRolesInName)(rolesName); //Filter roles created (avoid duplicate)

  let rolesToCreate;

  if (rolesFound) {
    rolesToCreate = roles.filter(r => !rolesFound.some(f => f.name == r.name));
  } else {
    rolesToCreate = roles;
  }

  const rolesCreated = await rolesToCreate.reduce(async (memo, role) => {
    const results = await memo;
    console.log(`Creating ${role.name}`);
    let childRoles = [];

    if (role.childRoles && role.childRoles.length > 0) {
      for (const childRoleName of role.childRoles) {
        let cr = await (0, _RoleService.findRoleByName)(childRoleName);

        if (cr) {
          childRoles.push(cr.id);
        }
      }

      role.childRoles = childRoles;
    }

    role = await (0, _RoleService.createRole)(role);
    console.log(`Created ${role.name}`);
    return [...results, role];
  }, []);
  rolesCreated.forEach(r => {
    loggingEvent("created", "role", r.name, r.id);
  }); //Update Roles

  const rolesUpdated = await rolesFound.reduce(async (memo, role) => {
    const results = await memo;
    console.log(`Updating ${role.name}`);
    let p = roles.find(r => r.name === role.name).permissions;
    let crs = roles.find(r => r.name === role.name).childRoles;
    let childRoles = [];

    if (crs && crs.length > 0) {
      for (const childRoleName of crs) {
        let cr = await (0, _RoleService.findRoleByName)(childRoleName);

        if (cr) {
          childRoles.push(cr.id);
        } else {}
      }
    }

    role = await (0, _RoleService.updateRole)(role.id, {
      name: role.name,
      permissions: p,
      childRoles: childRoles,
      readonly: role.readonly
    });
    console.log(`Updated ${role.name}`);
    return [...results, role];
  }, []);
  rolesUpdated.forEach(r => {
    loggingEvent("updated", "role", r.name, r.id);
  });
  return {
    rolesCreated: rolesCreated,
    rolesUpdated: rolesUpdated
  };
};

exports.initRoles = initRoles;

const initRootUser = async user => {
  if (!user) {
    user = _rootUser.rootUser;
  }

  let roleAdmin = await (0, _RoleService.findRoleByName)("admin");

  if (!roleAdmin) {
    throw Error('Root user cant be created. Role "admin" not found. ');
  }

  let u = await (0, _UserService.findUserByUsername)(user.username);

  if (!u) {
    u = await (0, _UserService.createUser)({ ...user,
      role: roleAdmin.id
    });
    loggingEvent("created", "user", u.username, u.id);
  } else {
    loggingEvent("found", "user", u.username, u.id);
  }
};

exports.initRootUser = initRootUser;

const initSupervisorUser = async user => {
  if (!user) {
    user = _supervisorUser.supervisorUser;
  }

  let roleSupervisor = await (0, _RoleService.findRoleByName)("supervisor");

  if (!roleSupervisor) {
    throw Error('Supervisor user cant be created. Role "supervisor" not found. ');
  }

  let u = await (0, _UserService.findUserByUsername)(user.username);

  if (!u) {
    u = await (0, _UserService.createUser)({ ...user,
      role: roleSupervisor.id
    });
    loggingEvent("created", "user", u.username, u.id);
  } else {
    loggingEvent("found", "user", u.username, u.id);
  }
};

exports.initSupervisorUser = initSupervisorUser;

const initOperatorUser = async user => {
  if (!user) {
    user = _operatorUser.operatorUser;
  }

  let roleOperator = await (0, _RoleService.findRoleByName)("operator");

  if (!roleOperator) {
    throw Error('Operator user cant be created. Role "supervisor" not found. ');
  }

  let u = await (0, _UserService.findUserByUsername)(user.username);

  if (!u) {
    u = await (0, _UserService.createUser)({ ...user,
      role: roleOperator.id
    });
    loggingEvent("created", "user", u.username, u.id);
  } else {
    loggingEvent("found", "user", u.username, u.id);
  }
};

exports.initOperatorUser = initOperatorUser;

const rootRecover = async (password = "root.123") => {
  (0, _UserService.findUserByUsername)("root").then(rootUser => {
    (0, _UserService.changePasswordAdmin)(rootUser.id, {
      password: password,
      passwordVerify: password
    }, rootUser.id).then(result => {
      _loggerBackend.DefaultLogger.info(result);
    }).catch(e => _loggerBackend.DefaultLogger.error("rootRecover ", e));
  });
};

exports.rootRecover = rootRecover;

const initLdapSettings = async () => {
  const settings = await (0, _settingsBackend.initializeSettings)(_ldapSettings.LDAP_SETTINGS);
  return settings;
};

exports.initLdapSettings = initLdapSettings;