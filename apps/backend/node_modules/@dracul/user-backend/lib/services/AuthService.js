"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tokenSignPayload = exports.refreshAuth = exports.generateRefreshToken = exports.auth = exports.apiKey = void 0;

var _loggerBackend = require("@dracul/logger-backend");

var _bcryptjs = _interopRequireDefault(require("bcryptjs"));

var _SessionService = require("./SessionService");

var _jsonwebtoken = _interopRequireDefault(require("jsonwebtoken"));

var _LoginFailService = require("./LoginFailService");

var _UserService = require("./UserService");

var _PasswordService = require("./PasswordService");

var _dayjs = _interopRequireDefault(require("dayjs"));

var _LdapService = require("./LdapService");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  v4: uuidv4
} = require('uuid');

const auth = function ({
  username,
  password
}, req) {
  return new Promise(async (resolve, reject) => {
    let user = null;
    let decodedPassword = (0, _PasswordService.decodePassword)(password);

    if (await (0, _LdapService.isLdapAuthEnable)()) {
      try {
        const user = await (0, _LdapService.authLdapAndGetUser)(username, decodedPassword);

        if (!user) {
          _loggerBackend.DefaultLogger.error('No se pudo obtener ni crear el usuario local para LDAP');
        }
      } catch (error) {
        _loggerBackend.DefaultLogger.error('LDAP AUTH ERROR ' + error);
      }
    }

    if (!user) {
      user = await (0, _UserService.findUserByUsername)(username); //Si obtuve usuario chequeo la password

      if (user && !checkPassword(decodedPassword, user.password)) {
        _loggerBackend.DefaultLogger.warn('AuthService.auth: BadCredentials => ' + username);

        (0, _LoginFailService.createLoginFail)(username, req);
        return reject('BadCredentials');
      }
    }

    if (!user) {
      _loggerBackend.DefaultLogger.warn('AuthService.auth: UserDoesntExist => ' + username);

      return reject('UserDoesntExist');
    } else if (user && user.active === false) {
      _loggerBackend.DefaultLogger.warn('AuthService.auth: DisabledUser => ' + username);

      return reject('DisabledUser');
    }

    try {
      const session = await (0, _SessionService.createSession)(user, req);
      let {
        token,
        payload,
        options
      } = generateToken(user, session.id);
      const refreshToken = await updateRefreshToken(user, session);

      _loggerBackend.DefaultLogger.info('AuthService.auth successful by ' + user.username);

      return resolve({
        token,
        payload,
        options,
        refreshToken
      });
    } catch (error) {
      _loggerBackend.DefaultLogger.error('AuthService.auth.createSession ', error);

      return reject(error);
    }
  });
};

exports.auth = auth;

const tokenSignPayload = function (user, sessionId) {
  return {
    id: user.id,
    username: user.username,
    role: {
      id: user.role.id,
      name: user.role.name,
      childRoles: user.role.childRoles
    },
    groups: user.groups.map(g => {
      id: g.id;
    }),
    idSession: sessionId
  };
};

exports.tokenSignPayload = tokenSignPayload;

async function updateRefreshToken(user, session) {
  if (user.refreshToken && user.refreshToken.length > 0) {
    const now = new Date();
    const refreshTokensToDelete = user.refreshToken.filter(rf => {
      const expiryDate = new Date(rf.expiryDate);
      return now > expiryDate ? true : false;
    });

    for (let refreshToken of refreshTokensToDelete) {
      user.refreshToken.pull(refreshToken);
    }
  } //AGREGAMOS NUEVO REFRESH TOKEN


  const refreshToken = generateRefreshToken(session.id);

  if (!user.refreshToken) {
    user.refreshToken = [];
  }

  user.refreshToken.push(refreshToken);
  await user.save();
  return refreshToken;
}

function checkPassword(decodedPassword, userPassword) {
  return _bcryptjs.default.compareSync(decodedPassword, userPassword);
}

const apiKey = function (userId, req) {
  return new Promise(async (resolve, reject) => {
    (0, _UserService.findUser)(userId).then(user => {
      const payload = {
        id: user.id,
        username: user.username,
        role: {
          name: user.role.name
        }
      };
      const options = {
        jwtid: user.id
      };

      if (user) {
        let token = _jsonwebtoken.default.sign(payload, process.env.JWT_SECRET, options);

        resolve({
          token,
          payload,
          options
        });
      }

      reject("User doesn't exist");
    }).catch(err => {
      _loggerBackend.DefaultLogger.error('AuthService.apiKey ', err);

      reject(err);
    });
  });
};

exports.apiKey = apiKey;

const refreshAuth = function (refreshTokenId) {
  return new Promise(async (resolve, reject) => {
    try {
      const user = await (0, _UserService.findUserByRefreshToken)(refreshTokenId);

      if (user) {
        let sessionId;

        for (let refreshToken of user.refreshToken) {
          if (refreshToken.id === refreshTokenId) {
            sessionId = refreshToken.sessionId;
            break;
          }
        }

        let {
          token
        } = generateToken(user, sessionId);
        return resolve(token);
      } else {
        return reject(new Error("Invalid RefreshToken"));
      }
    } catch (error) {
      () => reject(error);
    }
  });
};

exports.refreshAuth = refreshAuth;

const generateToken = (user, sessionId) => {
  const payload = tokenSignPayload(user, sessionId);
  const options = {
    expiresIn: process.env.JWT_LOGIN_EXPIRED_IN || '1h',
    jwtid: user.id
  };

  let token = _jsonwebtoken.default.sign(payload, process.env.JWT_SECRET, options);

  return {
    token,
    payload,
    options
  };
};

const generateRefreshToken = sessionId => {
  const DEFAULT_REFRESHTOKEN_EXPIRED_IN = '24h';
  const duration = process.env.JWT_REFRESHTOKEN_EXPIRED_IN || DEFAULT_REFRESHTOKEN_EXPIRED_IN;

  if (!/[0-9]+[dwMyhms(ms)]/.test(duration)) {
    throw new Error("JWT_REFRESHTOKEN_EXPIRED_IN invalid format /[0-9]+[dwMyhms(ms)/");
  }

  let number = duration.match(/[0-9]+/)[0];
  let unit = duration.match(/[dwMyhms(ms)]/)[0];
  let expiredAt = (0, _dayjs.default)().add(number, unit);
  const refreshToken = {
    id: uuidv4(),
    expiryDate: expiredAt.valueOf(),
    sessionId: sessionId
  };
  return refreshToken;
};

exports.generateRefreshToken = generateRefreshToken;