"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateGroup = exports.removeUserToGroup = exports.paginateGroup = exports.findGroupByName = exports.findGroup = exports.fetchMyGroups = exports.fetchGroups = exports.deleteGroup = exports.createGroup = exports.addUserToGroup = void 0;

var _loggerBackend = require("@dracul/logger-backend");

var _GroupModel = _interopRequireDefault(require("./../models/GroupModel"));

var _apolloServerExpress = require("apollo-server-express");

var _UserService = require("./UserService");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const addUserToGroup = function (groupId, userId) {
  return _GroupModel.default.findByIdAndUpdate(groupId, {
    $push: {
      users: userId
    }
  }, {
    new: true,
    useFindAndModify: false
  });
};

exports.addUserToGroup = addUserToGroup;

const removeUserToGroup = function (groupId, userId) {
  return _GroupModel.default.findByIdAndUpdate(groupId, {
    $pull: {
      users: userId
    }
  }, {
    new: true,
    useFindAndModify: false
  });
};

exports.removeUserToGroup = removeUserToGroup;

const fetchGroups = async function () {
  return new Promise((resolve, reject) => {
    _GroupModel.default.find({}).isDeleted(false).populate('users').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("GroupService.fetchGroups ", err);

        reject(err);
      }

      _loggerBackend.DefaultLogger.debug("GroupService.fetchGroups successful");

      resolve(res);
    });
  });
};

exports.fetchGroups = fetchGroups;

const fetchMyGroups = async function (userId) {
  return new Promise((resolve, reject) => {
    _GroupModel.default.find({
      users: {
        $in: [userId]
      }
    }).isDeleted(false).populate('users').exec((err, res) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("GroupService.fetchMyGroups ", err);

        reject(err);
      }

      _loggerBackend.DefaultLogger.debug("GroupService.fetchMyGroups successful");

      resolve(res);
    });
  });
};

exports.fetchMyGroups = fetchMyGroups;

const paginateGroup = function (limit, pageNumber = 1, search = null, orderBy = null, orderDesc = false, includesUser = null) {
  function qs(search, includesUser) {
    let qs = {};
    let or = [];

    if (includesUser) {
      or.push({
        users: {
          $in: [includesUser]
        }
      });
    }

    if (search) {
      or.push({
        name: {
          $regex: search,
          $options: 'i'
        }
      });
    }

    if (search || includesUser) {
      qs = {
        $or: or
      };
    }

    return qs;
  }

  function getSort(orderBy, orderDesc) {
    if (orderBy) {
      return (orderDesc ? '-' : '') + orderBy;
    } else {
      return null;
    }
  }

  let query = {
    deleted: false,
    ...qs(search, includesUser)
  };
  let populate = null;
  let sort = getSort(orderBy, orderDesc);
  let params = {
    page: pageNumber,
    limit: limit,
    populate,
    sort
  };
  return new Promise((resolve, reject) => {
    _GroupModel.default.paginate(query, params).then(result => {
      let docs = result.docs.map(async group => {
        group.users = await (0, _UserService.findUsersGroup)(group);
        return group;
      });

      _loggerBackend.DefaultLogger.debug("GroupService.paginateGroup successful");

      resolve({
        items: docs,
        totalItems: result.totalDocs,
        page: result.page
      });
    }).catch(err => {
      _loggerBackend.DefaultLogger.error("GroupService.paginateGroup ", err);

      reject(err);
    });
  });
};

exports.paginateGroup = paginateGroup;

const findGroup = async function (id) {
  return new Promise((resolve, reject) => {
    _GroupModel.default.findOne({
      _id: id
    }).populate('users').exec((err, doc) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("GroupService.findGroup ", err);

        return reject(err);
      }

      _loggerBackend.DefaultLogger.debug("GroupService.findGroup successful");

      resolve(doc);
    });
  });
};

exports.findGroup = findGroup;

const findGroupByName = async function (name) {
  return new Promise((resolve, reject) => {
    _GroupModel.default.findOne({
      name: {
        $eq: name
      }
    }).isDeleted(false).populate('users').exec((err, doc) => {
      if (err) {
        _loggerBackend.DefaultLogger.error("GroupService.findGroupByName", err);

        return reject(err);
      }

      if (Array.isArray(doc) && doc.length === 0) return resolve(null);
      if (Array.isArray(doc) && doc.length === 1) return resolve(doc[0]);
      resolve(doc);
    });
  });
};

exports.findGroupByName = findGroupByName;

const createGroup = async function (user, {
  name,
  color,
  users
}) {
  if (await findGroupByName(name)) {
    return Promise.reject(new _apolloServerExpress.UserInputError('Group validation fail', {
      inputErrors: {
        name: {
          name: "ValidatorError",
          message: "validation.unique",
          properties: {
            message: "validation.unique",
            type: "unique",
            path: "name",
            value: name
          }
        }
      }
    }));
  }

  const doc = new _GroupModel.default({
    name,
    color,
    users
  });
  doc.id = doc._id;
  return new Promise((resolve, reject) => {
    doc.save(async error => {
      if (error) {
        if (error.name == "ValidationError") {
          _loggerBackend.DefaultLogger.warn("GroupService.createGroup.ValidationError ", error);

          return reject(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        }

        _loggerBackend.DefaultLogger.error("GroupService.createGroup ", error);

        return reject(error);
      }

      await (0, _UserService.setUsersGroups)(doc, users);
      doc.users = await (0, _UserService.findUsersGroup)(doc);

      _loggerBackend.DefaultLogger.info("GroupService.createGroup successful for " + doc.name);

      resolve(doc);
    });
  });
};

exports.createGroup = createGroup;

const updateGroup = async function (user, id, {
  name,
  color,
  users = []
}) {
  let ge = await findGroupByName(name);

  if (ge && ge._id.toString() != id) {
    return Promise.reject(new _apolloServerExpress.UserInputError('Group validation fail', {
      inputErrors: {
        name: {
          name: "ValidatorError",
          message: "validation.unique",
          properties: {
            message: "validation.unique",
            type: "unique",
            path: "name",
            value: name
          }
        }
      }
    }));
  }

  return new Promise((resolve, reject) => {
    _GroupModel.default.findOneAndUpdate({
      _id: id
    }, {
      name,
      color,
      users
    }, {
      new: true,
      runValidators: true,
      context: 'query'
    }, async (error, doc) => {
      if (error) {
        if (error.name == "ValidationError") {
          _loggerBackend.DefaultLogger.warn("GroupService.updateGroup.ValidationError ", error);

          reject(new _apolloServerExpress.UserInputError(error.message, {
            inputErrors: error.errors
          }));
        }

        _loggerBackend.DefaultLogger.error("GroupService.updateGroup ", error);

        reject(error);
      }

      await (0, _UserService.setUsersGroups)(doc, users);
      doc.users = await (0, _UserService.findUsersGroup)(doc);

      _loggerBackend.DefaultLogger.info("GroupService.updateGroup successful for " + doc.name);

      resolve(doc);
    });
  });
};

exports.updateGroup = updateGroup;

const deleteGroup = function (id) {
  return new Promise((resolve, reject) => {
    findGroup(id).then(doc => {
      doc.softdelete(function (err) {
        if (err) {
          _loggerBackend.DefaultLogger.error("GroupService.deleteGroup ", err);

          reject(err);
        }

        _loggerBackend.DefaultLogger.info("GroupService.deleteGroup successful for " + doc.name);

        resolve({
          id: id,
          deleteSuccess: true
        });
      });
    });
  });
};

exports.deleteGroup = deleteGroup;